from sqlmodel import Session, select, delete
from database import *  # requires Backend.
from TableInfo import modelColumnInfo  # requires Backend.
from datetime import datetime
from random import randint, random
import csv
from pathlib import Path

# each field for each column, returns column value


def createColumnValue(columnName, columnType, currentIndex):
    if columnType == "str":
        return "{columnName} #{value}".format(columnName=columnName, value=str(currentIndex))
    if columnType == "float":
        return float(currentIndex)
    if columnType == "int":
        return int(currentIndex)
    if columnType == "bool":
        return True
    if columnType == "datetime":
        return datetime.now()
    return None

# create records with given size (yet to be inserted into the database)


def createRecords(modelName, noOfRecords):
    # to return
    records = []

    columns = modelColumnInfo[modelName]
    for i in range(1, noOfRecords+1):
        currentRecord = {}
        # each column
        for columnName, columnType in columns:
            currentRecord[columnName] = createColumnValue(
                columnName, columnType, i)
        records.append(currentRecord)
    return records

# getting rows of entity from another entity (with many-to-many)
# Unusable at the moment
# def getRowsFromManyToMany(manyToManyRelationModel, modelToObtain, targetModelIdName, modelToObtainIdName, targetModelIdValue):
#     try:
#         session = Session(engine)
#         resultantRows = []
#         getEntityStatement = select(manyToManyRelationModel).where(
#             manyToManyRelationModel.targetModelIdName == targetModelIdValue)
#         entityStatementResult = session.exec(getEntityStatement).all()
#         for row in entityStatementResult:
#             getEntityStatement = select(modelToObtain).where(
#                 modelToObtain.modelToObtainIdName == row.modelToObtainIdName)
#             entityStatementResult = session.exec(getEntityStatement).one()
#             if (entityStatementResult):
#                 resultantRows.append(entityStatementResult)
#         return {
#             "success": True,
#             "data": resultantRows
#         }
#     except Exception as e:
#         return {
#             "success": False,
#             "messaage": e,
#             "data":[]
#         }


# seed data for given entity
def seedInitialData(modelName, model, NoOfRecords=25, autoGenerated=True, fileName=""):
    try:
        session = Session(engine)
        stmt = select(model)
        result = session.exec(stmt).first()
        # check if duplicates
        if result is None:
            # autogen data
            if (autoGenerated):
                if modelName == "learningjourney":
                    listOfRoles = session.exec(select(RoleModel)).all()
                    listOfStaff = session.exec(select(StaffModel)).all()
                    for i in range(len(listOfStaff)):
                        selectedStaff = listOfStaff[i].Staff_ID
                        selectedRole = listOfRoles[randint(
                            0, len(listOfRoles)-1)].Role_ID
                        newLearningJourney = LearningJourneyModel()
                        newLearningJourney.LearningJourney_ID = i
                        newLearningJourney.Staff_ID = selectedStaff
                        newLearningJourney.Role_ID = selectedRole
                        session.add(newLearningJourney)
                else:
                    recordsToAdd = createRecords(modelName, NoOfRecords)
                    for record in recordsToAdd:
                        session.add(model(**record))
            # import
            else:
                base_dir = Path(__file__).resolve().parent
                data_file = base_dir.joinpath("data").joinpath(fileName+".csv")
                with open(data_file, encoding='cp1252') as csvFile:
                    csvReader = csv.DictReader(csvFile)
                    for record in csvReader:
                        session.add(model(**record))
            session.commit()
        session.close()

        return {
            "success": True,
            "message": "Data is seeded"
        }
    except Exception as e:
        return {
            "success": False,
            "messaage": str(e)
        }

# delete all data for given entity


def deleteAllData(model):
    session = Session(engine)
    stmt = delete(model)
    result = session.exec(stmt)
    session.commit()
    session.close()
    if result:
        return {
            "success": True,
            "message": "Everything is deleted"
        }
    return {
        "success": False,
        "message": "Failed to delete"
    }
